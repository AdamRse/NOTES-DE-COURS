/////////////// EXEMPLE NOUVEAU PROJET
Pour voir si symfony est configuré correctement
    symfony check:requirements
Créer le projet symfony
    symfony new <repertoireProjet> --version="7.0.*" --webapp
        --version="7.0.*" est optionel, par défaut sumfony prend la dernière version comptible avec la version de PHP utilisée
        --webapp pour un site internet
Dans .env, ajouter la BDD
    DATABASE_URL="mysql://<user>:<mdp>@<ip>:3306/<nomBdd>"
        le :<mdp> est optionel s'il n'y a pas de mot de passe
Créer les controlleur
    php bin/console make:controller
Créer les entités
    php bin/console make:entity
Créer le fichier de migration
    php bin/console make:migration
Créer la bdd
    php bin/console doctrine:migrations:migrate
        ou php bin/console d:m:m
Créer le crud
    php bin/console make:crud
Gestion des users
    php bin/console make:user
/////////////// PAGES
Faire un controller
    php bin/console make:controller
    Il sera créé dans templates/<nomDuControler>
Ajouter une route
    Ajouter une page templates/<nomController>/<nomPage>.html.twig
    Dans le controller src/<ontroller/<nomController>.php :
        #[Route(<nomRoute>, name: <nameRoute>)]
        public function <route>(): Response {
            $variable = 'Totoooooo';
            return $this->render('<nomController>/<nomPage>.html.twig', [
                'variable' => $variable, //variable utilisable dans la page
            ]);
        }
            <nomRoute> : String uri (par exemple "/", ou "/accueil")
            <nameRoute> : Nom de la page
            <nomPage> : nom de la page html
    Un controlleur peut assigner une arborescence de route à toutes ses méthodes. Par exemple pour avoir la route /campaign/show :
        #[Route('/campaign')]
        class CampaignController{
            #[Route('/show', name: 'show')]
            public function homeShow(): Response
            {
                return $this->render('campaign/show.html.twig', [
                ]);

            }
    On peut rediriger sur une autre reoure dans le return de la méthode route
        return $this->redirectToRoute(<nomPage>, [], Response::HTTP_SEE_OTHER);
Modèle base
    Chaque page peut être héritée d'un modèle qui se trouve dans templates/base.html.twig
    On peut y écrire la structure html, et y définir l'endroit de blocs appelés par la page
        {% block <nomBloc> %}{% endblock %}
Page
    On créé la page dans templates/<nomController>/<nomPage>.html.twig
    On utilise une base comme modèle, donc on écrira les blocks du modèle comme ceci :
        {% extends 'base.html.twig' %}
        {% block <nomBloc> %}
            //html
        {% endblock %}
            Par exemple :
                {% extends 'base.html.twig' %}
                {% block title %}Index{% endblock %}
                {% block body %}<h1>Hello world</h1>{% endblock %}
                {% block javascript %}<script>console.log("hello world")</script>{% endblock %}
    On peut utiliser le variables passées avec {{ <nomVariable> }}
        <nomVariable> sans $
    On peut utiliser les assets avec un chemin absolu asset()
        par exemple src="{{ asset('css/styles.css') }}" irra chercher assets/css/styles.css
        On utilise les assets pour les feuilles de style, images, js, etc
    On peut érire le chemin d'une page par son nom (<nameRoute>)
        par ex : href="{{ path('<nameRoute>') }}"
            on trouve <nameRoute> dans le controller à la ligne #[Route(<nomRoute>, name: <nameRoute>)] de la page correspondante

/////////////// BDD
Créer une base de données
Aller dans .env
    DATABASE_URL="mysql://root:@127.0.0.1:3306/<nomBdd>>"
1 entity = 1 table
Créer une entitée
    php bin/console make:entity
        >Nom de la table
        property = colonne
    Pour faire une relation (foreign key) : créer la property (colonne), avec le type relation
        >Donner le nom de l'entité (table) à laquelle elle est reliée
/!\Il est mieux de faire les relations entre table après avoir fait toutes les entités, car on ne peut pas modifier un champs.
    La technique quand il y a des interdépendances, c'est de créer les tables sauf les champs avec une relation, et d'ajouter le champs après que toutes les entitées et leurs ID soient créés. Si on a déjà créé le champ, on peut le supprimer dans /src/Entity/<nomEntitée>
Une fois les entitées créées, créer un fichier de migration vers la BDD
    php bin/console make:migration
        le fichier va apparaitre dans migration/<version>.php
Créer la bdd avec doctrine (doctrine est le pdo de symfony en plus puissant)
    php bin/console doctrine:migrations:migrate
Créer le CRUD
    php bin/console make:crud
        >Choisir l'entitée (la table) du crud
        >Choisir le nom du controlleur qui servira d'accès au crud
            On peut avoir la même route qu'un autre controlleur, mais avec des requêtes get ou post. Le contrôleur sera choisis en fonction de la présence des ces requêtes ou non lors de l'appel de la page
        Ses composants html exploitables de base vont se créer dans templates/<nomController> pour permettre le CRUD.
L'objet $form
    Un objet Form s'est créé dans src/Form/<nomController>Type.php pour pouvoir gérer le formulaire de modification de la table.
    Dans le controlleur, l'objet $form est ajouté et exploitable; par exemple dans la route /new
        l'objet $form et passé à la vue par le controlleur (par le return). La vue exploite le formulaire par défaut dans templates/<nomControlleur>/_form.html.twig
    Pour ajouter un attribut à un input de builder dans src/Form/<nomController>Type.php :
        $builder->add('<nomColonneBdd>', null, ['attr' => ['<nomAttribut>' => '<dansLattribut>']]);

/////////////// GESTION DES USER
Pour créer les utilisateurs et une entité dédiée pour la migration
    php bin/console make:user
        Créé une entité dans /src/Entity/<nomEntity>
        Créé un repository dans /src/<nomEntity>Repository.php
Une fois l'user créé, il faut faire une migration.
Faire un système d'authentification, qui gère l'e-mail, le formulaire de login, les mdp
    php bin/console make:auth
        créé un fichier spécial dans /src/Security/<nomAuthentificator> qui gère les vérifications de sécurité
        créé un controlleur dédié au login (si on a choisis l'option) dans /src/Controller/<nomControlleur>
            créé aussi une vue associée à la route login dans templates/security/login.html.twig
On aura aussi besoin d'un formulaire pour enregistrer un user
    php bin/console make:registration-form
        Ne créé pas d'entitée mais modifie celle créée par make:user
        créé un formulaire dans /src/Form/<nomFormulaire>
        créée un controlleur d'enregistrement dans /src/Controller/ResistrationController.php
        créé une vue dans /templates/registration/register.html.twig

/////////////// FORMULAIRES
Utiliser un formulaire du CRUD avec twig
    form_start(form) et form_end(form) : fonctions qui crééent des balises <form>
    form_row(form.<nomColonneBdd>) : Ajoute l'input qui servira à insérer <nomColonneBdd> en Bdd
Créer un formulaire dans le controlleur à partir d'un CRUD
    $form = $this->createForm(<tableBdd>Type::class, <objetEntity>);
Pour réceptionner le formulaire, on peut le remplir avec la requête Request $request (à passer dans la méthode du controlleur de la page)
    $form->handleRequest($request);
        par exemple avec un nouveau payment :
            $payment = new Payment();
            $form = $this->createForm(PaymentType::class, $payment);
            $form->handleRequest($request);
            $payment->getParticipant()->setCampaign($campaign);

/////////////// ELEMENTS
dd(<variable>);
    var_dump symfony avec avec un die.

/////////////// COMMANDES UTILES
php bin/console
    Ouvre la console de debug


/////////////// SYNTAXE TWIG UTILE
Avoir la taille d'un tableau
    <tableau> | length
envoyer une requête get avec path(). exemple avec un id de l'objet campaign
    href="{{ path('<nomPage>', {'id' : campaign.id}) }}"

////// Exemple de cours
formulaire sans crud
    ajouter les names sur l'input
    {{ app.request.query.get("id") }}
process du formulaire payment
    récupérer les valeurs de request : $i = $request->request->get("<nomInput>") // Get n'est pas méthode get, ça marche aussi pour post
    $payment = new Payment(); $participant = new participant();
    $payment->set<nomInput>($i); $participant->setName($request->request->get("<nomInput>"))
    $campaign = $campaignRepository->find($request->request->get("<nomInput>"))
Enregistrer en bdd
    ajout de EntityManagerInterface $entityManager en paramètre de la méthode
    $entityManager->persist($payment);
    $entityManager->flush();
récupérer une campagne
    mettre CampaignRepository $campaignRepository en paramètre de la méthode
    $campaign = $campaignRepository->find($request->request->get("<nomInputCampaignId>"))
///
On ne créé pas d'entité de table pivot (relation many to many)
